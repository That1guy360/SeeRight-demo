<html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SeeRight Classic</title>

<style>
body {
  font-family: Arial, sans-serif;
  margin:0;
  padding:24px;
  background:#111;
  color:#fff;
  text-align:center;
}
.wrap { max-width: 820px; margin: 0 auto; }
.controls {
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  justify-content:center;
  margin-bottom:14px;
}
input {
  padding:10px;
  border-radius:10px;
  border:1px solid #333;
  background:#0b0b0b;
  color:#fff;
  width:160px;
}
button {
  padding:10px 14px;
  border-radius:10px;
  border:1px solid #fff;
  background:transparent;
  color:#fff;
  cursor:pointer;
}
canvas {
  background:#fff;
  border-radius:12px;
  margin-top:14px;
}
#err {
  margin-top:14px;
  background:#300;
  padding:10px;
  display:none;
  white-space:pre-wrap;
}
</style>
</head>
<body>

<div class="wrap">
<h1>SeeRight Classic</h1>

<div class="controls">
  <input type="number" id="sphere" placeholder="Sphere (-2.00)" step="0.25" />
  <input type="number" id="cyl" placeholder="Cylinder (-1.00)" step="0.25" />
  <input type="number" id="axis" placeholder="Axis (0–180)" step="1" min="0" max="180" />
  <button id="applyBtn">Apply</button>
  <button id="toggleBtn">Before / After</button>
</div>

<canvas id="glcanvas" width="500" height="500"></canvas>

<img id="chart" src="SeeRight_Chart.png" style="display:none;" />

<pre id="err"></pre>
</div>

<div class="card">
  <h3>Join Early Access</h3>
  <div class="muted">
    Enter your prescription + device. Help improve calibration.
    No spam. No login required.
  </div>

  <iframe 
    src="https://docs.google.com/forms/d/e/1FAIpQLScIigh7GwKQuwz0049LPMuTFxMq7pyNpAKMTndySmCmEwDzQw/viewform?embedded=true"
    width="100%" 
    height="600"
    style="border:none; border-radius:12px; margin-top:10px;">
  </iframe>
</div>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
const errBox = document.getElementById("err");

function showErr(m){
  errBox.style.display="block";
  errBox.textContent=m;
}

if(!gl){
  showErr("WebGL not supported");
  throw new Error("WebGL not supported");
}

const vertexShaderSource = `
attribute vec2 a_position;
varying vec2 v_uv;
void main(){
  v_uv = (a_position * 0.5) + 0.5;
  gl_Position = vec4(a_position,0.0,1.0);
}
`;

const fragmentShaderSource = `
precision mediump float;

uniform sampler2D u_tex;
uniform float u_sphere;
uniform float u_cyl;
uniform float u_axis;
uniform bool u_apply;
uniform vec2 u_px;

varying vec2 v_uv;

vec4 blur9(sampler2D t, vec2 uv, vec2 px, float amt){
  vec2 r = px * amt;
  vec4 c = vec4(0.0);
  c += texture2D(t, uv + r*vec2(-1.0,-1.0))*0.0625;
  c += texture2D(t, uv + r*vec2(0.0,-1.0))*0.125;
  c += texture2D(t, uv + r*vec2(1.0,-1.0))*0.0625;
  c += texture2D(t, uv + r*vec2(-1.0,0.0))*0.125;
  c += texture2D(t, uv + r*vec2(0.0,0.0))*0.25;
  c += texture2D(t, uv + r*vec2(1.0,0.0))*0.125;
  c += texture2D(t, uv + r*vec2(-1.0,1.0))*0.0625;
  c += texture2D(t, uv + r*vec2(0.0,1.0))*0.125;
  c += texture2D(t, uv + r*vec2(1.0,1.0))*0.0625;
  return c;
}

void main(){
  vec2 uv = v_uv;
  uv.y = 1.0 - uv.y;

  float s = clamp(u_sphere, -10.0, 10.0);
  float cyl = clamp(u_cyl, -6.0, 6.0);
  float axis = radians(u_axis);

  float strength = abs(s) + abs(cyl)*0.5;
  vec4 base = blur9(u_tex, uv, u_px, strength*1.5);

  if(u_apply){
    vec2 c = uv - 0.5;
    float r2 = dot(c,c);

    float k1 = s * 0.06;
    float k2 = s * 0.02;

    float factor = 1.0 + k1*r2 + k2*r2*r2;

    float angleFactor = cos(axis)*c.x + sin(axis)*c.y;
    factor += cyl * 0.02 * angleFactor;

    uv = 0.5 + c * factor;
    uv = clamp(uv,0.002,0.998);
    gl_FragColor = texture2D(u_tex, uv);
  }else{
    gl_FragColor = base;
  }
}
`;

function compile(type,source){
  const s=gl.createShader(type);
  gl.shaderSource(s,source);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    showErr(gl.getShaderInfoLog(s));
    throw new Error("Shader compile fail");
  }
  return s;
}

const vs=compile(gl.VERTEX_SHADER,vertexShaderSource);
const fs=compile(gl.FRAGMENT_SHADER,fragmentShaderSource);

const program=gl.createProgram();
gl.attachShader(program,vs);
gl.attachShader(program,fs);
gl.linkProgram(program);

if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
  showErr(gl.getProgramInfoLog(program));
  throw new Error("Program link fail");
}

gl.useProgram(program);

const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
-1,-1,1,-1,-1,1,
-1,1,1,-1,1,1
]),gl.STATIC_DRAW);

const posLoc=gl.getAttribLocation(program,"a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

const sphereLoc=gl.getUniformLocation(program,"u_sphere");
const cylLoc=gl.getUniformLocation(program,"u_cyl");
const axisLoc=gl.getUniformLocation(program,"u_axis");
const applyLoc=gl.getUniformLocation(program,"u_apply");
const texLoc=gl.getUniformLocation(program,"u_tex");
const pxLoc=gl.getUniformLocation(program,"u_px");

gl.uniform2f(pxLoc,1.0/canvas.width,1.0/canvas.height);

gl.uniform1i(texLoc,0);
gl.uniform1i(applyLoc,0);

const texture=gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D,texture);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);

const chart=document.getElementById("chart");

function upload(){
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,chart);
  draw();
}

chart.onload=upload;
if(chart.complete && chart.naturalWidth>0){ upload(); }

function draw(){
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(1,1,1,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES,0,6);
}

let applied=false;

document.getElementById("applyBtn").onclick=()=>{
  const s=parseFloat(document.getElementById("sphere").value)||0;
  const c=parseFloat(document.getElementById("cyl").value)||0;
  const a=parseFloat(document.getElementById("axis").value)||0;

  gl.uniform1f(sphereLoc,s);
  gl.uniform1f(cylLoc,c);
  gl.uniform1f(axisLoc,a);

  applied=true;
  gl.uniform1i(applyLoc,1);
  draw();
};

document.getElementById("toggleBtn").onclick=()=>{
  applied=!applied;
  gl.uniform1i(applyLoc,applied?1:0);
  draw();
};

draw();
</script>
</body>
</html>
