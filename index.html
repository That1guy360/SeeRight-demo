<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SeeRight Demo</title>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:24px; background:#111; color:#fff; text-align:center; }
    .wrap { max-width: 820px; margin: 0 auto; }
    h1 { margin: 0 0 10px 0; font-size: 28px; }
    .sub { opacity: 0.85; margin: 0 0 18px 0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; margin: 10px 0 14px 0; }
    input { padding:10px; border-radius:10px; border:1px solid #333; background:#0b0b0b; color:#fff; width:180px; }
    button { padding:10px 14px; border-radius:10px; border:1px solid #fff; background:transparent; color:#fff; cursor:pointer; }
    button:active { transform: translateY(1px); }
    canvas { background:#fff; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .row { margin-top: 14px; }
    .card { margin:18px auto 0 auto; max-width:520px; text-align:left; border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:14px; }
    .card h3 { margin:0 0 6px 0; font-size: 16px; }
    .muted { opacity:.85; font-size: 14px; line-height: 1.35; }
    .pill { display:inline-block; margin-top:10px; padding:10px 14px; border:1px solid #fff; border-radius:10px; text-decoration:none; color:#fff; }
    #msg { margin-top:12px; font-size:14px; opacity:.9; min-height:18px; }
    #err { text-align:left; white-space:pre-wrap; background:#300; color:#fff; padding:10px; border-radius:10px; margin-top:14px; display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>SeeRight</h1>
    <p class="sub">Join the movement on vision correction. Runs locally in your browser. No login. No uploads.</p>

    <div class="controls">
      <input type="number" id="sphere" placeholder="Sphere (e.g., -2.00)" step="0.25" />
      <button id="applyBtn">Apply</button>
      <button id="toggleBtn">Before / After</button>
    </div>

    <canvas id="glcanvas" width="500" height="500"></canvas>

    <!-- Hidden chart image used as the WebGL texture -->
    <img id="chart" src="snellen.png" alt="Snellen chart" crossorigin="anonymous" style="display:none;" />

    <div class="row">
      <div>Did this improve clarity?</div>
      <div class="controls" style="margin-top:8px;">
        <button id="fbYes">Yes</button>
        <button id="fbNo">No</button>
      </div>
      <div id="msg"></div>
    </div>

    <div class="card">
      <h3>Get early access</h3>
      <div class="muted">Join the early release list. No spam. You’ll be first when Android builds drop.</div>
      <a class="pill" href="https://forms.gle/h7cDnUiehPr83Dw97" target="_blank" rel="noopener">Join Early Access</a>
    </div>

    <pre id="err"></pre>
  </div>

  <script>
    const errBox = document.getElementById("err");
    function showErr(msg){
      errBox.style.display = "block";
      errBox.textContent = msg;
    }
    window.onerror = (m, s, l, c) => showErr(`JS ERROR: ${m}\n${s}:${l}:${c}`);

    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl", { preserveDrawingBuffer: true });

    if (!gl) {
      showErr("WebGL not available in this browser/device.");
      throw new Error("WebGL not available");
    }

    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = (a_position * 0.5) + 0.5;   // -1..1 -> 0..1
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

const fragmentShaderSource = `
precision mediump float;

uniform sampler2D u_tex;
uniform float u_sphere;
uniform bool u_apply;

uniform bool u_sim;     // NEW: simulate blur driven by sphere
uniform vec2 u_px;      // NEW: 1.0/width, 1.0/height

varying vec2 v_uv;

vec4 blur9(sampler2D t, vec2 uv, vec2 px, float amt) {
  // amt scales sample radius; keep subtle
  vec2 r = px * amt;

  vec4 c = vec4(0.0);
  c += texture2D(t, uv + r * vec2(-1.0,-1.0)) * 0.0625;
  c += texture2D(t, uv + r * vec2( 0.0,-1.0)) * 0.125;
  c += texture2D(t, uv + r * vec2( 1.0,-1.0)) * 0.0625;

  c += texture2D(t, uv + r * vec2(-1.0, 0.0)) * 0.125;
  c += texture2D(t, uv + r * vec2( 0.0, 0.0)) * 0.25;
  c += texture2D(t, uv + r * vec2( 1.0, 0.0)) * 0.125;

  c += texture2D(t, uv + r * vec2(-1.0, 1.0)) * 0.0625;
  c += texture2D(t, uv + r * vec2( 0.0, 1.0)) * 0.125;
  c += texture2D(t, uv + r * vec2( 1.0, 1.0)) * 0.0625;

  return c;
}

void main() {
  vec2 uv = v_uv;

  // chart upright (keep)
  uv.y = 1.0 - uv.y;

  // OPTIONAL: blur simulation driven by |sphere|
  vec4 base;
  if (u_sim) {
    float s = clamp(abs(u_sphere), 0.0, 10.0);
    float amt = s * 2.0;        // 0 at 0.00, grows with sphere
    base = blur9(u_tex, uv, u_px, amt);
  } else {
    base = texture2D(u_tex, uv);
  }

  // APPLY correction distortion (your existing correction)
  if (u_apply) {
    vec2 c = uv - 0.5;
    float r2 = dot(c, c);
    float s = clamp(u_sphere, -10.0, 10.0);
    float k1 = s * 0.06;
    float k2 = s * 0.02;
    float factor = 1.0 + k1 * r2 + k2 * r2 * r2;
    uv = 0.5 + c * factor;
    uv = clamp(uv, 0.002, 0.998);

    // after warp, sample again (blur sim should be "before", correction is "after")
    gl_FragColor = texture2D(u_tex, uv);
  } else {
    // before: show unwarped image (blur sim may apply here)
    gl_FragColor = base;
  }
}
`;
      function compileShader(type, source) {
      const sh = gl.createShader(type);
      gl.shaderSource(sh, source);
      gl.compileShader(sh);
      if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(sh) || "Unknown shader error";
        showErr("SHADER COMPILE FAIL:\n" + info);
        throw new Error(info);
      }
      return sh;
    }

    const vs = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
    const fs = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program) || "Unknown program link error";
      showErr("PROGRAM LINK FAIL:\n" + info);
      throw new Error(info);
    }

    gl.useProgram(program);

    // Fullscreen quad
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1
    ]), gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
const sphereLoc = gl.getUniformLocation(program, "u_sphere");
const applyLoc  = gl.getUniformLocation(program, "u_apply");
const texLoc    = gl.getUniformLocation(program, "u_tex");

// ADD THESE RIGHT HERE
const simLoc = gl.getUniformLocation(program, "u_sim");
const pxLoc  = gl.getUniformLocation(program, "u_px");

gl.uniform1i(simLoc, 1);
gl.uniform2f(pxLoc, 1.0 / canvas.width, 1.0 / canvas.height);

    gl.uniform1f(sphereLoc, 0.0);
    gl.uniform1i(applyLoc, 0);

    // Texture setup
    const texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(texLoc, 0);

    // 1x1 placeholder until image loads
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
      gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255,255,255,255])
    );

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    function draw() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(1, 1, 1, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    
   const chartImg = document.getElementById("chart");

function uploadChartTextureAndDraw() {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, chartImg);
  draw();
}

chartImg.onload = uploadChartTextureAndDraw;
chartImg.onerror = () => showErr("Image failed to load: snellen.png (must be in repo root).");

// If cached, onload may not fire:
if (chartImg.complete && chartImg.naturalWidth > 0) {
  uploadChartTextureAndDraw();
}


chartImg.onload = uploadChartTextureAndDraw;
chartImg.onerror = () => showErr("Image failed to load: snellen.png (must be in repo root).");

// If the image is already cached, onload may not fire—force it:
if (chartImg.complete && chartImg.naturalWidth > 0) {
  uploadChartTextureAndDraw();
}
;

    // Controls
    let applyEffect = false;

    document.getElementById("applyBtn").onclick = () => {
      const sphere = parseFloat(document.getElementById("sphere").value) || 0.0;
      gl.uniform1f(sphereLoc, sphere);
      applyEffect = true;
      gl.uniform1i(applyLoc, 1);
      draw();
    };

    document.getElementById("toggleBtn").onclick = () => {
      applyEffect = !applyEffect;
      gl.uniform1i(applyLoc, applyEffect ? 1 : 0);
      draw();
    };

    // Feedback
    const msg = document.getElementById("msg");
   document.getElementById("fbYes").onclick = () => {
  msg.textContent = "Thanks. Email: see.right.2020@gmail.com";
};
   document.getElementById("fbNo").onclick = () => {
    msg.textContent = "Thanks. Comment with your sphere value + device model so I can tune it.";
    };

    // Initial draw (placeholder until image loads)
    draw();
  </script>
</body>
</html>
